---
layout: post
title:  "[golang]学习:自增id,uuid和雪花算法"
date:   2023-07-30
categories: golang
---

自增id,uuid和雪花算法的优劣以及区别

## 介绍

#### 自增ID

自增ID简单的说就是在向表中插入一条数据时不用自己设置id的值，数据库引擎会自动根据表中的数据的id+1进行填充。

由于是数据库引擎负责生成的主键id，因此不需要我们自己处理主键重复的问题，同时生成比较简单，速度快，并且因为是增量生成的，在插入和查找数据的时候可以比使用随机的值具有更好的性能。

以MySQL为例，数据存储在主索引（B+树）的叶子节点上，因此同一叶子节点的各条数据继续需要按主键顺序进行存储，当由一条新的数据插入的时候，如果向新数据的主键处于已有数据主键的中间值，可能需要为了将新数据插入到对应的位置而移动数据，会增加额外的开销。

同时由于id是根据插入的顺序递增的，对开发人员来说，在某种程度上会比使用近乎随机值的UUID更加直观。而且相比UUID需要128位进行存储，自增id通常仅需要使用64位的无符号整型(0,18446744073709551615)就可以满足绝大部分的场景需求。



#### UUID

UUID——通用唯一标识码（Universally Unique Identifier）

UUID最早由Apollo Computers在1990年提出，随后由OSF（Open Software Foundation）标准化。UUID有128位组成，通常表示为32个16进制数。

UUID到目前为止有5个版本。

这里简单说一些各个版本的区别：

UUID v1 基于时间戳和MAC地址生成，但时间精度不足时使用clock sequence来扩展时间戳。由于此版本依赖于设备供应商提供唯一的MAC地址，因此可以通常它反查到对应的MAC地址。
UUID v2 没有提供实现细节，基本很少使用。
UUID v3,v5 都是通过hash namespace的标识符和名称生成的，不同在于v3使用MD5作为hash函数，v5使用SHA-2做hash函数。当输入的namespace与参数相同时会输出相同的UUID。
UUID v4 除了4位表示版本和2-3位标识varant外，其余位全部随机。这是用得最广泛的版本。
五个版本都可以保证唯一，但是不管是那个版本生成的UUID，对数据库而已生成的UUID值都近乎随机。


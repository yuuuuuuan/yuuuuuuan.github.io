---
layout: post
title:  "[golang]算法:岛屿问题"
date:   2023-08-01
categories: golang	DFS
---

岛屿问题

## 介绍

给你一个大小为 `m x n` 的二进制矩阵 `grid` 。

**岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在 **水平或者竖直的四个方向上** 相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

岛屿的面积是岛上值为 `1` 的单元格的数目。

计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0` 。

**示例 1：**
![image](/assets/maxarea1-grid.jpg)

```
输入：grid = 
[[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
输出：6
解释：答案不应该是 11 ，因为岛屿只能包含水平或垂直这四个方向上的 1 。
```

## 思路

#### 深度优先搜索

- 我们想知道网格中每个连通形状的面积，然后取最大值。

- 如果我们在一个土地上，以 4 个方向探索与之相连的每一个土地（以及与这些土地相连的土地），那么探索过的土地总数将是该连通形状的面积。

- 为了确保每个土地访问不超过一次，我们每次经过一块土地时，将这块土地的值置为 其他值。这样我们就不会多次访问同一土地。

## 代码

```
func maxAreaOfIsland(grid [][]int) int {
    if len(grid) == 0 {
        return 0
    }

    rows := len(grid)
	cols := len(grid[0])
    maxnum := 0
    
    var dfs func(int, int) int
    dfs = func(i, j int) int {
		if i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] != 1 {
			return 0
		}
		grid[i][j] = -1 // 标记当前位置已访问
		count := 1      // 当前池塘的大小

		// 搜索相邻的4个方向
		count += dfs(i+1, j)   // 右
		count += dfs(i-1, j)   // 左
		count += dfs(i, j+1)   // 上
		count += dfs(i, j-1)   // 下
		
		return count
	}

    for i := 0; i < rows; i++ {
		for j := 0; j < cols; j++ {
			if grid[i][j] == 1 {
				count := dfs(i, j)
				if count>maxnum {
                    maxnum = count
                }
			}
		}
	}

    return maxnum
}
```


---
layout: post
title:  "[golang]学习:自增id,uuid和雪花算法"
date:   2023-07-30
categories: golang
---

自增id,uuid和雪花算法的优劣以及区别(未完成)

## 介绍

#### 自增ID

自增ID简单的说就是在向表中插入一条数据时不用自己设置id的值，数据库引擎会自动根据表中的数据的id+1进行填充。

由于是数据库引擎负责生成的主键id，因此不需要我们自己处理主键重复的问题，同时生成比较简单，速度快，并且因为是增量生成的，在插入和查找数据的时候可以比使用随机的值具有更好的性能。

以MySQL为例，数据存储在主索引（B+树）的叶子节点上，因此同一叶子节点的各条数据继续需要按主键顺序进行存储，当由一条新的数据插入的时候，如果向新数据的主键处于已有数据主键的中间值，可能需要为了将新数据插入到对应的位置而移动数据，会增加额外的开销。

同时由于id是根据插入的顺序递增的，对开发人员来说，在某种程度上会比使用近乎随机值的UUID更加直观。而且相比UUID需要128位进行存储，自增id通常仅需要使用64位的无符号整型(0,18446744073709551615)就可以满足绝大部分的场景需求。



#### UUID

UUID——通用唯一标识码（Universally Unique Identifier）

UUID最早由Apollo Computers在1990年提出，随后由OSF（Open Software Foundation）标准化。UUID有128位组成，通常表示为32个16进制数。

UUID到目前为止有5个版本。

这里简单说一些各个版本的区别：

- **v1 版本说明**

v1 是基于当前时间戳、机器 MAC 地址生成的，因为 MAC 地址是全球唯一的。从而保证 UUID 唯一，这种方式其实暴露了 MAC 地址和生成时间。

- **v2版本说明**

基于时间的 UUID 算法相同，会把时间戳的前4位换成 POSIX 的UID 和GID

- **v3版本说明**

用户指定了一个命名空间和一个具体字符串， 然后通过 MD5散列来生成 UUID。

- **v4基于随机数**

根据随机数或者伪随机数生成 UUID， 这个版本用的比较多。



